/**create RDD

spark-shell --master yarn \
	--conf spark.ui.port=12654 \
	--num-executors 1 \
	--executor-memory 512M
sc.getConf.getAll.foreach(println)


val orders = sc.textFile("/public/retail_db/orders")
orders.first
orders.take(10)

val productsRaw = scala.io.Source.fromFile("/data/retail_db/products/part-00000").getLines.toList

val productsRDD = sc.parallelize(productsRaw)

productsRDD.take(10)

orders.count

orders.takeSample(true,100)
orders.takeSample(true,100).foreach(println)

orders.collect



/*scenarioA to read json

val ordersDF=sqlContext.read.json("/public/retail_db_json/orders")
ordersDF.show
ordersDF.schema
ordersDF.select("order_id","order_date")
ordersDF.select("order_id","order_date").show

/*scenarioB to read json
val ordersDF=sqlContext.load("/public/retail_db/orders","json")
ordersDF.show




/*****transform stage and store

val orders=sc.textFile("/public/retail_db/orders")
val str = orders.first
val a = str.split(",")
a(0)
a(1)
a(2)

val orderid = a(0)
val orderid = a(0).toInt

a(1)
a(1).contains("2017")
a(1).contains("2013")

val orderDate=a(1)
orderDate.substring(0,10)
orderDate.substring(5,7)
orderDate.substring(11)


orderDate.replace('-','/')
orderDate.replace("07","July")

orderDate.indexOf("2")
orderDate.indexOf("2", 2)

/*** map

val orders=sc.textFile("/public/retail_db/orders")
val orderDates = orders.map((str: String) => {
 str.split(",")(1).substring(0,10).replace("-","").toInt 
})
orderDates.take(10).foreach(println)



val ordersPairedRDD=orders.map(order=>{
 val o = order.split(",")
 (o(0)).toInt, o(1).substring(0,10).replace("-","").toInt)
})
ordersPairedRDD.take(10).foreach(println)


val orderItems=sc.textFile("/public/retail_db/order_items")
val orderItemsPairedRDD=orderItems.map(orderItem =>{
	(orderItems.split(",")(1).toInt, orderItem)
})

orderItems.take(10).foreach(println)



/*** flatmap

val l = List("hello","How are you doing","Let us perform word count","As part of the word count program","we will see how many times each word repeat")

val l_rdd=sc.parallelize(l)
val l_map=l_rdd.map(ele => ele.split(" "))
val l_flatMap=l_rdd.flatMap(ele => ele.split(" "))

l_map.collect.foreach(println)
l_flatMap.collect.foreach(println)

val wordcount = l_flatMap.map(word => (word, "")).countByKey


/*** filters

val orders=sc.textFile("/public/retail_db/orders")

orders.filter(order => order.split(",")(3) == "COMPLETE")
orders.filter(order => order.split(",")(3) == "COMPLETE").take(10).foreach(println)

orders.filter(order => order.split(",")(3) == "COMPLETE").count

val s = orders.first
s.contains("COMPLETE") || s.contains("CLOSED")

s.split(",")(3).contains("COMPLETE") || s.split(",")(3).contains("CLOSED")

(s.split(",")(3)=="COMPLETE" || s.split(",")(3)=="CLOSED") && (s.split(",")(1).contains("2013-07-25"))
(s.split(",")(3)=="COMPLETE" || s.split(",")(3)=="CLOSED") && (s.split(",")(1).contains("2013-08-25"))

orders.filter(order => order.split(",")(3)=="COMPLETE")
orders.filter(order => order.split(",")(3)=="COMPLETE").count

orders.map(order => order.split(",")(3)).distinct
orders.map(order => order.split(",")(3)).distinct.collect.foreach(println)


val ordersFiltered = orders.filter(order => {
	val o = order.split(",")
	(o(3) == "COMPLETE" || o(3) == "CLOSED") && (o(1).contains("2013-09"))
})

ordersFiltered.take(10).foreach(println)
ordersFiltered.count




/*** **  joins


/*** inner join

val orders=sc.textFile("/public/retail_db/orders")
val orderitems=sc.textFile("/public/retail_db/order_items")


val ordersMap=orders.map(order=> {
 (order.split(",")(0).toInt,order.split(",")(1).substring(0,10))
})
ordersMap.take(10).foreach(println)
orders.count
ordersMap.count


val orderItemsMap=orderItems.map(orderItem=> {
 val oi=orderItem.split(",")
 (oi(1).toInt,oi(4).toFloat)
})
orderItemsMap.take(10).foreach(println)
orderItemsMap.count
orderItemsMap.count

val ordersJoin = ordersMap.join(orderItemsMap)
ordersJoin.take(10).foreach(println)
ordersJoin.count



/*** outer join

val ordersMap=orders.map(order=> {
 (order.split(",")(0).toInt,order)
})

val orderItemsMap=orderItems.map(orderItem=> {
 val oi=orderItem.split(",")
 (oi(1).toInt,orderItem)
})

val ordersLeftOuterJoin = ordersMap.leftOuterJoin(orderItemsMap)
val ordersRightOuterJoin = orderItemsMap.leftOuterJoin(ordersMap)

val t = ordersLeftOuterJoin.first
t._2._2

val ordersLeftOuterJoinFilter = ordersLeftOuterJoin.filter(order=>order._2._2==None)
ordersLeftOuterJoinFilter.take(10).foreach(println)

val ordersWithNoOrderItem = ordersLeftOuterJoinFilter.map(order=>order._2._1)
ordersWithNoOrderItem.take(10).foreach(println)


val ordersWithNoOrderItem = ordersRightOuterJoin.
 filter(order=>order._2._1==None).
 map(order=>order._2._2)
ordersWithNoOrderItem.take(10).foreach(println)






/*****aggregations

/*countByKey, reduce, groupByKey

val orders=sc.textFile("/public/retail_db/orders")

orders.map(order=>(order.split(",")(3),"")).countByKey.foreach(println)

val orderItems=sc.textFile("/public/retail_db/order_items/")
orderItems.take(10).foreach(println)

val orderItemsRevenue = orderItems.map(oi=> oi.split(",")(4).toFloat)
orderItemsRevenue.take(10).foreach(println)
orderItemsRevenue.reduce((total, revenue) => total+revenue)

val orderItemsMaxRevenue=orderItemsRevenue.reduce((max,revenue) => {
 if(max<revenue) revenue else max
})

val orderItemsMap = orderItems.map(oi => (oi.split(",")(1).toInt, oi.split(",")(4).toFloat))
orderItemsMap .take(10).foreach(println)  

val orderItemsGBK=orderItemsMap.groupByKey
orderItemsGBK.take(10).foreach(println)    

orderItemsGBK.map(rec=>rec._2.toList.sum).take(10).foreach(println)

orderItemsGBK.map(rec=>(rec._1, rec._2.toList.sum)).take(10).foreach(println)  

/** sorting

val l = Iterable(343,5,6343,7,1).toList

l.sorted
l.sortBy(o=>-o)

val ordersSortedByRevenue = orderItemsGBK.
 flatMap(rec=>{
 rec._2.toList.sortBy(o=>-o).map(k=>(rec._l,k))
})

ordersSortedByRevenue.take(10).foreach(println)  


/* reduceByKey

val orderItems=sc.textFile("/public/retail_db/order_items/") 
val orderItemsMap = orderItems.map(oi => (oi.split(",")(1).toInt, oi.split(",")(4).toFloat))

val revenuePerOrderId=orderItemsMap.
 reduceByKey((total, revenue)=>total+revenue)

val minRevenuePerOrderId=orderItemsMap.
 reduceByKey((min, revenue)=>if(min>revenue) revenue else min)

revenuePerOrderId.take(10).foreach(println)
minRevenuePerOrderId.take(10).foreach(println)

orderItemsMap.sortByKey().take(10).foreach(println)

minRevenuePerOrderId.sortByKey().take(10).foreach(println)


/* aggregateByKey

val orderItems=sc.textFile("/public/retail_db/order_items/") 
val orderItemsMap = orderItems.map(oi => (oi.split(",")(1).toInt, oi.split(",")(4).toFloat))

val revenueAndMaxPerProductID=orderItemsMap.
 aggregateByKey((0.0, 0.0))(
 (inter, subtotal)=>(inter._1+subtotal, if(subtotal>inter._2) subtotal else inter._2),
 (total, inter)=>(total._1+inter._1, if(total._2>inter._2) total._2 else inter._2)
)
revenueAndMaxPerProductID.take(10).foreach(println)

revenueAndMaxPerProductID.sortByKey().take(10).foreach(println)

//(order_id, order_item_subtotal)
val revenueAndMaxPerProductID=orderItemsMap.
 aggregateByKey((0.0f, 0.0f))(
 (inter, subtotal)=>(inter._1+subtotal, if(subtotal>inter._2) subtotal else inter._2),
 (total, inter)=>(total._1+inter._1, if(total._2>inter._2) total._2 else inter._2)
)
//(order_id, (order_revenue, max_order_item_subtotal))





